# DM Toolkit Integration Tasks

1. **Confirm environment readiness**: Load `/home/barrulus/1_projects/questables/.env.local`, verify database connectivity on port 3001, and document any credential gaps before touching code.
2. **Audit existing campaign data flow**: Review `database/schema.sql`, `database/migration.sql`, `server/database-server.js`, and `components/campaign-manager.tsx` to catalogue the current campaign tables, endpoints, and UI so the DM Toolkit scope plugs into live pathways without mock shortcuts.
3. **Design migration strategy**: Draft the full DDL changes for campaigns, spawn points, objectives, and session extras in a new migration file under `database/` (mirrored in `schema.sql`) with rollback support and SRID 0 enforcement for all new geometries.
4. **Implement unique name constraint**: Update the migration to create `uq_campaign_name_per_dm` on `(dm_user_id, lower(name))` and add an associated constraint check in `server/database-server.js` responses so duplicate-name attempts return a descriptive 409.
5. **Create `campaign_spawns` table**: Add the table definition, default flag uniqueness, timestamps, and GIST index; ensure `setup-database.js` applies the migration and update any seed/bootstrap scripts that assume a single spawn record.
6. **Create `campaign_objectives` table**: Include hierarchy via `parent_id`, location union fields, order index, LLM markdown columns, and GIST index for pins; backfill existing campaigns with empty objective trees where required to avoid null reference issues.
7. **Extend `sessions` schema**: Add `dm_focus` and `dm_context_md` columns through migration and confirm `server/database-server.js` queries select these new fields for existing session payloads.
8. **Update database TypeScript types**: Regenerate or hand-maintain TypeScript interfaces/enums (e.g., in `components/campaign-shared.ts` and any server-side typings) so new columns and tables are available end-to-end.
9. **Add data validation helpers**: In `server/utils` (or a new module), implement utility functions enforcing `objective_location` rules (single location, matching `location_type`) and reuse them across objective create/update controllers.
10. **Wire campaign CRUD endpoints**: Add real implementations for `POST/PUT/GET /api/campaigns` and `GET /api/users/:userId/campaigns` in `server/database-server.js`, using shared query builders and ensuring `requireAuth` plus DM ownership checks via `server/auth-middleware.js`.
11. **Implement spawn API**: Create route handler `PUT /api/campaigns/:campaignId/spawn` that performs an upsert, validates SRID, marks previous defaults false, and returns fresh spawn data; surface backend errors to the client without silent fallbacks.
12. **Implement objective APIs**: Build handlers for create/list/update/delete under `/api/campaigns/:campaignId/objectives` and `/api/objectives/:objectiveId`, supporting tree persistence, order re-indexing, and ensuring deletes cascade to children as specified.
13. **Expose LLM assist endpoints**: Add the five `/api/objectives/:objectiveId/assist/*` routes that call `server/llm/contextual-service.js` with the correct narrative type, persist the generated text (e.g., via `llm_narratives` table), and return the real response—no mock payloads.
14. **Extend DM Sidebar APIs**: Implement focus/context update endpoints, unplanned encounter creation, NPC sentiment adjustments (touching `npc_relationships`), and teleport actions that update `campaign_players.loc_current` plus append to `player_movement_audit` with transaction safety.
15. **Centralize permission checks**: Add middleware/helpers (e.g., `server/utils/dm-authorization.js`) to validate DM/co-DM access for campaigns, objectives, sessions, and NPCs; reuse it across all new routes to prevent drift.
16. **Register routes and tests**: Mount the new endpoints in the Express router, update OpenAPI/API documentation (`API_DOCUMENTATION.md`), and add Supertest integration specs in `tests/server/` verifying success and failure modes with the live database.
17. **Surface backend errors to UI**: Ensure every new controller returns structured error payloads consumed by the client (e.g., `{ error: code, message }`) so React components can display accurate toasts instead of generic failures.
18. **Expand API client utilities**: Update `utils/api-client.ts` (and any fetch wrappers) with methods for campaigns, spawn, objectives, sidebar actions, and teleportation; include abort signal support and JSON parsing guards consistent with existing helpers.
19. **Refine campaign manager UI**: Update `components/campaign-manager.tsx` and supporting modules to use the new API responses, expose world-map selection, enforce the 1–20 player + level-range constraints, and remove any placeholder defaults (e.g., static system/setting strings) per the zero-dummy policy.
20. **Build Campaign View shell**: Create a dedicated prep view component (e.g., `components/campaign-prep.tsx`) that loads campaign details, spawns, and objective tree using real data, wiring loading states and error boundaries.
21. **Implement spawn map tooling**: Enhance `components/openlayers-map.tsx` (or derivative) to support DM-only spawn pin placement, note editing modal, and immediately persist via the spawn API while reflecting the saved state after server confirmation.
22. **Develop objectives panel**: Build UI for single and multi-objective creation, tree visualization with drag/drop ordering (persisted to `order_index`), markdown editors for each content field, and location pickers that integrate with maps, burgs, and markers.
23. **Integrate LLM assist UI**: Connect assist buttons to the live endpoints, stream pending state, handle throttling/errors, and populate objective markdown fields with the actual LLM output while logging the assist call in telemetry.
24. **Assemble DM Sidebar**: Add a sidebar component tied to the active session, supporting focus/context edits (with append/replace toggle), unplanned encounter creation, NPC sentiment updates, and teleport actions, all backed by the corresponding APIs and with optimistic UI only where confirmed safe.
25. **Hook websocket or polling updates**: Use the existing `server/websocket-server.js` (or add polling) so spawn changes, objective updates, and sidebar actions reflect in real time for concurrent DM/co-DM sessions without stale state.
26. **Persist audit events**: Ensure server handlers log to the existing audit mechanism (or extend it) for campaign edits, spawn updates, objective CRUD, and teleport logs, and expose summaries in the UI where relevant.
27. **Add backend regression tests**: Expand `tests/server/` with cases covering migrations (via setup helpers), objective tree operations, teleport auditing, and permission failures; run them against the live DB (no mocks) and capture outputs for review.
28. **Add frontend tests**: Implement React Testing Library specs (e.g., in `tests/frontend/`) for campaign forms, objective tree interactions, and sidebar flows, using MSW or live API test doubles that hit the Express server in test mode only where unavoidable.
29. **Verify spatial queries**: Write manual/automated checks ensuring SRID 0 coordinates flow correctly from UI to DB and back; add assertions that spatial indexes exist by querying PostgreSQL catalogs in a migration verification script.
30. **Update documentation**: Refresh `README.md`, `API_DOCUMENTATION.md`, `DATABASE_SETUP.md`, and add a DM Toolkit section describing database changes, endpoints, and UI entry points; include LLM usage notes and failure handling expectations.
31. **Update operational guides**: Document required environment variables (LLM providers, map layers) and migration steps in `docs/` and ensure `.env.example` reflects new keys.
32. **Run linting & formatters**: Execute lint across touched files (e.g., `npx eslint components/... server/... --ext ts,tsx,js`) and record the command/output in `lint_report.md` per project policy.
33. **Execute end-to-end validation**: Spin up the full stack, run through campaign creation, spawn placement, objective editing, DM sidebar actions, and confirm database records match expectations with manual SQL spot checks.
34. **Log progress artifacts**: For each completed slice, append evidence to `clearance_and_connect_tasks_documentation.md` (migration hashes, test runs, screenshots) and attach any blockers immediately.
35. **Prepare release notes**: Draft a rollout checklist summarizing migrations, new env vars, and user-facing changes; coordinate with backend partners about endpoint readiness and monitoring hooks before deployment.
36. **Plan follow-up telemetry**: Ensure success/error metrics for new endpoints are added to whatever logging/monitoring system is in use (`server/utils/logger` or similar) and that alerts cover teleport failures or LLM outages.
37. **Final review & handoff**: Conduct a peer review focusing on zero-dummy compliance, ensure no placeholder data or dead code remains, and update `dmtoolkit_tasks.md` status markers once implementation begins.
